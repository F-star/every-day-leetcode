
# 40

难点在于要求要求返回的 **组合不能有重复的**。

## 思路

### 解法1：哈希表去重

这是我自己想出来的解法。然而代价是 **时间上只打败了 5% 的提交**。原因是要把符合条件（和为 target）的长度为 k 的数组进行拼接，形成 key，存到哈希表里，这里就出现了 O(k) 的时间复杂度。当提供的测试用例非常刁钻时，就会非常耗时。另外为了让 key 保持相同，我预先对 candidates 进行了排序。

### 解法2

其实上面我写得解法1，可以优化得到解法2，并能够减去很多枝叶。同样，先使用排序，将相同的元素相邻排布。然后，**对于连续多个相同的值，只处理开头第一个，剩余相同的跳过。** 因为走首值的时候就能覆盖掉所有的情况，它此时能够获得最多的相同值，它走过的路，后面几个相同值如果走，也只是首值的子集。进行这个处理，能够 **高效地剪枝**，提高效率